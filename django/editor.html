<title>DesktopHero - Editor</title>

<script>

  mode = "appearance";

  boneGroupTemplates = {};
  assetTemplates = {};
  poseTemplates = {};
  presets = {};

  boneGroups = new ObservableDict(this);

  materials = new Materials();
  view = new SceneView(); // This is the three.js panel
  view.animate();
  meshPickingView = new PickingView();
  posePickingView = new PosePickingView();
  selectedAsset = null;
  selectedBoneGroup = null;

  // bone manipulation
  selectedBone = null;
  editMode = 'none';
  rotationBoneOrigin = null;
  editMouseOriginX = 0;
  editMouseOriginY = 0;
  currentNumberString = '';
  raycaster = new THREE.Raycaster();
  X_AXIS = new THREE.Vector3(1,0,0);
  Y_AXIS = new THREE.Vector3(0,1,0);
  Z_AXIS = new THREE.Vector3(0,0,1);
  lastMouseX = null;
  lastMouseY = null;

  assetResolutionMode = 'low';

  // keyboard
  leftMouseDown = false;

  $(document).ready( function(){
    view.onWindowResize(); // Resize three.js panel to correct starting size
    meshPickingView.onWindowResize(); // Resize the mesh picking view too
    posePickingView.onWindowResize(); // Resize the pose picking view too

    initializeBoneGroupTemplates();
    initializeAssetTemplates();
    initializePoseTemplates();
    initializePresets();
    initializeMaterials();

    hideAssetTabs(); // hide asset tabs 
    initializeMenus();


    loadPreset("187983a1-3fe1-4279-b60a-100915a7da37");
    //loadBoneGroupsSimpleMode();
    view.requestRender();

    // enable clicks
    $('canvas')[0].addEventListener('mousedown', onMouseDown);
    $('canvas')[0].addEventListener('mouseup', onMouseUp);
    $('canvas')[0].addEventListener('mousemove', onMouseMove, true);
    document.addEventListener('keydown', onKeyDown, false);
  });


  function initializeBoneGroupTemplates(){
    {% for bone_group in bone_groups %}
      var template = new BoneGroupTemplate("{{ bone_group.id }}",
                                         "{{ bone_group.name }}",
                                         "{{ bone_group.description }}",
                                         "{{ bone_group.author }}",
                                         "{{ bone_group.categories }}".split(","),
                                         "{{ bone_group.date_created }}",
                                         "/static/" + "{{ bone_group.thumbnail.url }}",
                                         "/static/" + "{{ bone_group.file.url }}")
      boneGroupTemplates["{{ bone_group.id }}"] = template;
    {% endfor %}
  }

  function initializeAssetTemplates(){
    {% for asset in assets %}
      var template = new AssetTemplate("{{ asset.id }}",
                                       "{{ asset.name }}",
                                       "{{ asset.description }}",
                                       "{{ asset.author }}",
                                       "{{ asset.category }}",
                                       "{{ asset.date_created }}",
                                       "/static/" + "{{ asset.thumbnail.url }}",
                                       "/static/" + "{{ asset.mesh.url }}",
                                       "/static/" + "{{ asset.mesh_hires.url }}",
                                       "/static/" + "{{ asset.mesh_lowres.url }}")
      assetTemplates["{{ asset.id }}"] = template;
    {% endfor %}
  }

  function initializePoseTemplates(){
    {% for pose in poses %}
      var template = new PoseTemplate("{{ pose.id }}",
                                      "{{ pose.name }}",
                                      "{{ pose.description }}",
                                      "{{ pose.author }}",
                                      "{{ pose.category }}",
                                      "{{ pose.date_created }}",
                                      "/static/" + "{{ pose.thumbnail.url }}",
                                      "/static/" + "{{ pose.file.url }}")
      poseTemplates["{{ pose.id }}"] = template;
    {% endfor %}
  }

  function initializePresets(){
    {% for preset in presets %}
      var preset = new Preset( "{{ preset.id }}",
                               "{{ preset.name }}",
                               "{{ preset.description }}",
                               "{{ preset.author }}",
                               "{{ preset.category }}",
                               "{{ preset.date_created }}",
                               "/static/" + "{{ preset.thumbnail.url }}",
                               "/static/" + "{{ preset.file.url }}")
      presets["{{ preset.id }}"] = preset;
    {% endfor %}
  }

  function initializeMaterials(){
    materials.metallic = Materials.createReflectiveMaterial(new THREE.Color(0.75, 0.75, 0.7), .3, view.cubeMap);
    materials.selected = Materials.createReflectiveMaterial(new THREE.Color(0.7, .8, .9), .2, view.cubeMap);
    materials.boneGroupSelected = Materials.createReflectiveMaterial(new THREE.Color(0.9, .8, .6), .2, view.cubeMap);
    materials.clay = Materials.createReflectiveMaterial(new THREE.Color(0.5, 0.4, 0.5), 0.02, view.cubeMap);
    materials.basicGray = Materials.createBasicMaterial(new THREE.Color(0.6, 0.58, 0.6));
    materials.transparentGray = Materials.createTransparentMaterial(new THREE.Color(0.6, 0.58, 0.6));
    materials.default = materials.metallic;
  }

  function addBoneGroup(boneGroup){
    boneGroups.put(boneGroup.uid, boneGroup);
  }

  function getBoneGroupByTemplateId(template_id){
    for (var boneGroupUid in boneGroups.dict){
      var boneGroup = boneGroups.get(boneGroupUid);
      if (boneGroup.template.uuid == template_id){
        return boneGroup;
      }
    }
  }

  function getAssetByCategory(category){
    for (var boneGroupUid in boneGroups.dict){
      var boneGroup = boneGroups.get(boneGroupUid);
      for (var assetId in boneGroup.assets.dict){
        var asset = boneGroup.assets.get(assetId);
        if (asset.overrideCategory == category){
          return asset;
        }
      }
    }
  }

  function removeBoneGroup(uid){
    // Remove meshes attached to bone group
    var boneGroupToRemove = boneGroups.get(uid);
    for (var meshName in boneGroupToRemove.assets.dict){
      boneGroupToRemove.removeAsset(meshName);
    }

    for (var boneGroupUid in boneGroups.dict){
      var boneGroup = boneGroups.get(boneGroupUid);
      if (boneGroup.parentBoneGroupUid === uid){ //Remove child bone groups.
        removeBoneGroup(boneGroupUid);
      }
    }
    boneGroups.remove(uid);
  }

  function getCurrentPose(){
    return Pose.toPose(boneGroups);
  }

  function loadBoneScales(pose){
    for (var i = 0; i < pose.poseBones.length; i++){
      var poseBone = pose.poseBones[i];

      for (var boneGroupUid in boneGroups.dict){
        var boneGroup = boneGroups.get(boneGroupUid);

        for (var j = 0; j < boneGroup.skeleton.bones.length; j++){
          var bone = boneGroup.skeleton.bones[j];
          if (pose.affectedBones != undefined && pose.affectedBones.indexOf(bone.name) == -1){
            continue;
          }

          if (bone.name === poseBone.name){
            bone.scale.x = poseBone.scale.x;
            bone.scale.y = poseBone.scale.y;
            bone.scale.z = poseBone.scale.z;
          }
        }
      }
    }
  }

  function loadPose(pose){
    for (var i = 0; i < pose.poseBones.length; i++){
      var poseBone = pose.poseBones[i];

      for (var boneGroupUid in boneGroups.dict){
        var boneGroup = boneGroups.get(boneGroupUid);

        for (var j = 0; j < boneGroup.skeleton.bones.length; j++){
          var bone = boneGroup.skeleton.bones[j];
          if (pose.affectedBones != undefined && pose.affectedBones.indexOf(bone.name) == -1){
            continue;
          }

          if (bone.name === poseBone.name){
            bone.position.x = poseBone.position.x;
            bone.position.y = poseBone.position.y;
            bone.position.z = poseBone.position.z;

            bone.rotation.x = poseBone.rotation.x;
            bone.rotation.y = poseBone.rotation.y;
            bone.rotation.z = poseBone.rotation.z;
          }
        }
      }
    }
  }

  function loadJSONPose(jsonString){
    var pose = Pose.fromJson(jsonString);
    this.loadPose(pose);
  }

  function loadVariation(variation){
    for (var i = 0; i < variation.poseBones.length; i++){
      var poseBone = variation.poseBones[i];

      for (var boneGroupUid in boneGroups.dict){
        var boneGroup = boneGroups.get(boneGroupUid);

        for (var j = 0; j < boneGroup.skeleton.bones.length; j++){
          var bone = boneGroup.skeleton.bones[j];
          if (variation.affectedBones != undefined && variation.affectedBones.indexOf(bone.name) == -1){
            continue;
          }

          if (bone.name === poseBone.name){
            bone.scale.x = poseBone.scale.x;
            bone.scale.y = poseBone.scale.y;
            bone.scale.z = poseBone.scale.z;
          }
        }
      }
    }
  }

  function selectAsset(asset){
    // reset previously selected mesh to normal material
    if (selectedAsset != null){
      selectedAsset.mesh.material = materials.default;
    }
    view.requestRender();

    selectedAsset = asset;
    if (selectedAsset == null){
      return;
    }

    // reset newly selected mesh to selected material
    console.log("Selected asset " + asset.template.name);
    selectedAsset.mesh.material = materials.selected;
    view.requestRender();

    // show appropriate asset categories on the appearance menu
    /*hideAssetTabs();
    var boneGroup = boneGroups.get(selectedAsset.boneGroupUid);
    var categories = boneGroup.template.categories;
    for (var i = 0; i < categories.length; i++ ){
      var category = categories[i];
      showAssetTab(category);
    }
    setActiveAssetTab(categories[0]);*/
  }

  function selectBoneGroup(boneGroup){
    menuSelectBoneGroup(boneGroup);

    // reset previously selected bone group to normal material
    if (selectedBoneGroup != null){
      for (var assetId in selectedBoneGroup.assets.dict){
        var asset = selectedBoneGroup.assets.get(assetId);
        asset.mesh.material  = materials.default;
      }
    }
    view.requestRender();

    selectedBoneGroup = boneGroup;
    if (selectedBoneGroup == null){
      return;
    }

    // reset newly selected bone group to selected material
    console.log("Selected bone group " + boneGroup.template.name);
    for (var assetId in boneGroup.assets.dict){
      var asset = boneGroup.assets.get(assetId);
      asset.mesh.material  = materials.boneGroupSelected;
    }
    
    view.requestRender();



    // show appropriate asset categories on the appearance menu
    /*hideAssetTabs();
    var boneGroup = boneGroups.get(selectedAsset.boneGroupUid);
    var categories = boneGroup.template.categories;
    for (var i = 0; i < categories.length; i++ ){
      var category = categories[i];
      showAssetTab(category);
    }
    setActiveAssetTab(categories[0]);*/
  }

  function setResolution(setTo){
    if (assetResolutionMode == setTo){
      return;
    }

    assetResolutionMode = setTo;
    var json = JSON.parse(getCharacterJSON());
    clear();
    presetLoadBoneGroups(json);
  }

  function setMode(setTo){
    if (setTo == mode){
      return;
    }

    console.log("Entering " + setTo + " mode.");
    mode = setTo;

    if (mode != 'appearance' && selectedAsset != null){
      selectAsset(null);
    }

    if (mode != 'components' && selectedBoneGroup != null){
      selectBoneGroup(null);
    }

    view.requestRender();
  }

  function toJSON(){
    return {
      name: this.name,
      boneGroups: boneGroups.dict
    };
  }

  function getAsset(assetUid){
    for (var boneGroupUid in boneGroups.dict){
      var boneGroup = boneGroups.get(boneGroupUid);
      if (assetUid in boneGroup.assets.dict){
        return [boneGroupUid, boneGroup.assets.get(assetUid)];
      }
    }
    return null;
  }

  function clear(){
    for (var boneGroupUid in boneGroups.dict){
      this.removeBoneGroup(boneGroupUid);
    }
  }

  function exportToSTL(){
    var stlString = new THREE.STLExporter().parse(view.scene);
    var blob = new Blob([stlString], {type: 'text/plain'});
    
    FileSaver.download(blob, 'New Character.stl');
  }

  function presetLoadBoneGroups(preset){
    function fillInMissingComponents(components){
      {% for component in simple_mode_components %}
        var requiredCategory = "{{ component.category|safe }}";
        var alreadyExists = false;
        for (var i = 0; i < components.length; i++){
          if (components[i].category == requiredCategory){
            alreadyExists = true;
            break;
          }
        }
        if (!alreadyExists){
          components.push({
              "category": "{{ component.category|safe }}",
              "bone_id": "{{ component.bone.id|safe }}",
              "instance_id": "{{ component.instance_id|safe }}",
              "attach_to": "{{ component.attach_to|safe }}",
              "attach_point": "{{ component.attach_point|safe }}"
            });
        }
      {% endfor %}
    }

    var components = preset.components;
    fillInMissingComponents(components);
    var boneGroupUids = {};
    var boneGroupsLeftToBeLoaded = components.length;

    // Load all bone groups, proceed to next step when all loaded
    for (var i = 0; i < components.length; i++){
      var component = components[i];
      var template = boneGroupTemplates[component.bone_id];
      // Initialize a bone group instance from this template
      template.createInstance(function(boneGroup){
        console.log("Loaded bone group " + boneGroup.template.name + " from storage.");
        addBoneGroup(boneGroup);

        boneGroupUids[boneGroup.name] = boneGroup.uid;
        boneGroupsLeftToBeLoaded -= 1;
        if (boneGroupsLeftToBeLoaded <= 0){
          presetLoadMeshes(preset);
        }
      }, component.category, component.instance_id);
    }
  }



  function presetLoadMeshes(preset){
     function fillInMissingCategories(categories){
      {% for category in simple_mode_categories %}
        var requiredCategory = "{{ category.name_safe|safe }}";
        var alreadyExists = false;
        for (var i = 0; i < categories.length; i++){
          if (categories[i].override_category == requiredCategory){
            alreadyExists = true;
            break;
          }
        }
        if (!alreadyExists){
          categories.push({
              "name": "empty",
              "asset_id": "d0848a47-794d-4565-ba05-2a554facdac3",
              "override_category": "{{ category.name_safe|safe }}",
              "bone_instance_id": "{{ category.bone_instance_id|safe }}",
              "hide_initially": true
            });
        }
      {% endfor %}
    }
    var categories = preset.categories;
    fillInMissingCategories(categories);
    var meshesLeftToBeLoaded = categories.length;

    // Attach meshes to bone groups.
    for (var i = 0; i < categories.length; i++){
      var category = categories[i];
      var assetTemplateId = category.asset_id;
      var template = assetTemplates[assetTemplateId];
      var overrideCategory = category.override_category;
      if (template){
        // Initialize an asset instance from this template
        var boneGroupInstanceId = category.bone_instance_id;
        template.createInstance(function(asset, boneGroupId){
          console.log("Loaded asset " + asset.template.name + " from storage.");

          var boneGroup = boneGroups.get(boneGroupId);
          boneGroup.addAsset(asset);
          meshesLeftToBeLoaded -= 1;
          if (meshesLeftToBeLoaded <= 0){
            presetAttachBones(preset);
          }
        }, boneGroupInstanceId, overrideCategory);
      } else {
        console.error("No such asset template: " + assetTemplateId);
        meshesLeftToBeLoaded -= 1;
      }
      setCategoryVisible(overrideCategory, !category.hide_initially);
    }
  }

  function presetAttachBones(preset){
    var components = preset.components;

    // Attach bone groups to their correct parent bones.
    for (var i = 0; i < components.length; i++){
      var component = components[i];
      var boneGroupInstanceId = component.instance_id;
      var boneGroup = boneGroups.get(boneGroupInstanceId);

      var attachToInstanceId = component.attach_to;
      var attachToBoneGroup = boneGroups.get(attachToInstanceId);
      var attachToPoint = component.attach_point;

      if (attachToInstanceId != "None"){
        boneGroup.attachToBone(attachToBoneGroup.uid, attachToPoint, attachToBoneGroup.attachPoints[attachToPoint]);
      }
    }

    presetLoadPose(preset);
  }

  function presetLoadPose(preset){
    if (preset.pose){
      Pose.loadPose(preset.pose, boneGroups);
    }
  }

  /*components
    bone_id (template)
    instance_id
    attach_to (instance id)
    attach_point

  categories
    asset_id (template?)
    bone_instance_id*/

  function getCharacterJSON(){
    // Create character preset with components (bone groups) and categories (assets)
    preset = {};
    var components = [];
    var categories = [];

    function addComponentEntry(boneGroupChildren){
      for (var i = 0; i < boneGroupChildren.length; i++){
        var boneGroup = boneGroupChildren[i];
        console.log(boneGroup.template.name);
        // bone group entry
        var boneGroupEntry = {};
        boneGroupEntry["category"] = boneGroup.template.name;
        boneGroupEntry["bone_id"] = boneGroup.template.uuid;
        boneGroupEntry["instance_id"] = boneGroup.uid;
        var parentBone = boneGroup.parentBone;
        if (parentBone){
          boneGroupEntry["attach_to"] = boneGroup.parentBoneGroupUid;
          boneGroupEntry["attach_point"] = boneGroup.parentBoneName;
        } else {
          boneGroupEntry["attach_to"] = "None";
          boneGroupEntry["attach_point"] = "None";
        }
        components.push(boneGroupEntry);

        // asset entry
        var asset_instance_ids = Object.keys(boneGroup.assets.dict);
        for (var j = 0; j < asset_instance_ids.length; j++){
          var asset = boneGroup.assets.get(asset_instance_ids[j]);
          var visible = categoryVisible(asset.overrideCategory) && asset.mesh.visible;
          if (visible){
            var assetEntry = {
              "name": asset.template.name,
              "asset_id": asset.template.uuid,
              "bone_instance_id": boneGroup.uid,
              "override_category": asset.overrideCategory
            };
            categories.push(assetEntry);
          }
        }

        addComponentEntry(boneGroup.childBones);
      }
    }
    addComponentEntry(Pose.findTopLevelBoneGroups(boneGroups));

    preset.components = components;
    preset.categories = categories;
    preset.pose = getCurrentPose();

    return JSON.stringify(preset, ' ', ' ');
  }

  function saveCharacterFile(){
    var stlString = getCharacterJSON();
    var blob = new Blob([stlString], {type: 'text/plain'});
    FileSaver.download(blob, 'New Character.dhc');
  }

  function loadPreset(presetId){
    var preset = presets[presetId];
    if (!preset){
      console.error("No such preset: " + presetId);
      return;
    }

    clear();
    view.requestRender();

    // Initialize an preset instance from this template
    preset.getFileContents(function(preset){
      console.log("Loaded preset " + preset.name + " from storage.");
      var presetJson = JSON.parse(preset);
      presetLoadBoneGroups(presetJson);
    });
  }

  function loadJsonPreset(json){
    var self = this;
    preset = JSON.parse(json);

    var boneGroupsLeftToBeLoaded = Object.keys(preset.boneGroups).length;
    var boneGroupUids = {};

    // Check to make sure bone groups valid before loading preset
    for (var boneGroupInstanceId in preset.boneGroups){
      var boneGroupTemplateId = preset.boneGroups[boneGroupInstanceId];
      var template = boneGroupTemplates[boneGroupTemplateId];
      if (!template){
        console.error("No such bone group template: " + boneGroupTemplateId + ". Invalid preset.");
        return;
      }
    }

    // Load all bone groups, proceed to next step when all loaded
    for (var boneGroupInstanceId in preset.boneGroups){
      var boneGroupTemplateId = preset.boneGroups[boneGroupInstanceId];
      var template = boneGroupTemplates[boneGroupTemplateId];
      // Initialize a bone group instance from this template
      template.createInstance(function(boneGroup){
        console.log("Loaded bone group " + boneGroup.template.name + " from storage.");
        addBoneGroup(boneGroup);

        boneGroupUids[boneGroup.name] = boneGroup.uid;
        boneGroupsLeftToBeLoaded -= 1;
        if (boneGroupsLeftToBeLoaded <= 0){
          presetBoneGroupsAdded(preset, boneGroupUids);
        }
      }, 'fakecategory', boneGroupInstanceId);
    }
  }

  function loadBoneGroupsSimpleMode(){
    var boneGroupUids = {};
    var boneGroupsLeftToBeLoaded = {{ simple_mode_components|length }};

    // Load all bone groups, proceed to next step when all loaded
    //for (var boneGroupInstanceId in boneGroupUids){
    {% for component in simple_mode_components %}
      var template = boneGroupTemplates["{{ component.bone.id }}"];
      // Initialize a bone group instance from this template
      template.createInstance(function(boneGroup){
        console.log("Loaded bone group " + boneGroup.template.name + " from storage.");
        addBoneGroup(boneGroup);

        boneGroupUids[boneGroup.name] = boneGroup.uid;
        boneGroupsLeftToBeLoaded -= 1;
        if (boneGroupsLeftToBeLoaded <= 0){
          loadMeshesSimpleMode();
          // presetBoneGroupsAdded(preset, boneGroupUids);
        }
      }, 'fakecategory', "{{ component.instance_id|safe }}");
    {% endfor %}
  }

  function loadMeshesSimpleMode(){
    var meshesLeftToBeLoaded = {{ simple_mode_categories|length }};

    // Attach meshes to bone groups.
    {% for category in simple_mode_categories %}
      var assetTemplateId = "{{ category.asset.id }}";

      var empty = !assetTemplateId;
      if (empty){
        assetTemplateId = "d0848a47-794d-4565-ba05-2a554facdac3";
      }

      var template = assetTemplates[assetTemplateId];
      if (template){
        // Initialize an asset instance from this template
        var overrideCategory = "{{ category.name_safe }}";
        template.createInstance(function(asset){
          console.log("Loaded asset " + asset.template.name + " from storage.");

          var boneGroupInstanceId = "{{ category.bone_instance_id|safe }}";
          var boneGroup = boneGroups.get(boneGroupInstanceId);
          boneGroup.addAsset(asset);
          console.log(boneGroup.assets);
          meshesLeftToBeLoaded -= 1;
          if (meshesLeftToBeLoaded <= 0){
            attachBonesSimpleMode();
          }
        }, null, overrideCategory);
      } else {
        console.error("No such asset template: " + assetTemplateId);
        meshesLeftToBeLoaded -= 1;
        if (meshesLeftToBeLoaded <= 0){
          attachBonesSimpleMode();
        }
      }
    {% endfor %}
  }

  function attachBonesSimpleMode(preset, boneGroupUids){
    // Attach bone groups to their correct parent bones.
    {% for component in simple_mode_components %}
      var boneGroupInstanceId = "{{ component.instance_id|safe }}";
      var boneGroup = boneGroups.get(boneGroupInstanceId);

      var attachToInstanceId = "{{ component.attach_to|safe }}";
      var attachToBoneGroup = boneGroups.get(attachToInstanceId);
      var attachToPoint = "{{ component.attach_point }}";

      if (attachToInstanceId != "None"){
        boneGroup.attachToBone(attachToBoneGroup.uid, attachToPoint, attachToBoneGroup.attachPoints[attachToPoint]);
      }
    {% endfor %}
  }

  function presetBoneGroupsAdded(preset, boneGroupUids){
    var self = this;
    var meshesLeftToBeLoaded = Object.keys(preset.meshes).length;

    // Attach meshes to bone groups.
    for (var assetTemplateId in preset.meshes){
      var template = assetTemplates[assetTemplateId];
      if (!template){
        console.error("No such asset template: " + assetTemplateId);
        meshesLeftToBeLoaded -= 1;
        continue;
      }

      // Initialize an asset instance from this template
      template.createInstance(function(asset){
        console.log("Loaded asset " + asset.template.name + " from storage.");

        var boneGroupUid = preset.meshes[asset.template.uuid];
        var boneGroup = boneGroups.get(boneGroupUid);
        boneGroup.addAsset(asset);
        meshesLeftToBeLoaded -= 1;
        if (meshesLeftToBeLoaded <= 0){
          presetMeshesAdded(preset, boneGroupUids);
        }
      });
    }
  }

  function presetMeshesAdded(preset, boneGroupUids){
    // Attach bone groups to their correct parent bones.
    self = this;

    for (var boneGroupInstanceId in preset.attachments){
      var boneGroup = boneGroups.get(boneGroupInstanceId);

      var attachToUid = preset.attachments[boneGroupInstanceId][0];
      var attachToBoneGroup = boneGroups.get(attachToUid);
      var attachToPoint = preset.attachments[boneGroupInstanceId][1];

      boneGroup.attachToBone(attachToUid, attachToPoint, attachToBoneGroup.attachPoints[attachToPoint]);
    }

    // Load pose.
    // if (preset.pose != undefined){
    //   self.character.loadPose(preset.pose);
    // }
  }


  /* =====================================
      Click handlers
     ===================================== */

  function handleClickBoneGroupTemplate(boneGroupTemplateId){
    var template = boneGroupTemplates[boneGroupTemplateId];
    if (!template){
      console.error("No such bone group template: " + boneGroupTemplateId);
      return;
    }

    // Initialize a bone group instance from this template
    template.createInstance(function(boneGroup){
      console.log("Loaded bone group " + boneGroup.template.name + " from storage.");
      addBoneGroup(boneGroup);
    });

  }

  function handleClickAssetTemplate(assetTemplateId){
    if (selectedAsset == null){
      return;
    }

    if (!assetTemplateId){ // User selected 'None'
      // Mark mesh invisible
      selectedAsset.mesh.visible = false;
      view.requestRender();
      return;
    }

    // Make sure mesh is visible
    selectedAsset.mesh.visible = true;

    var template = assetTemplates[assetTemplateId];
    if (!template){
      console.error("No such asset template: " + assetTemplateId);
      return;
    }

    // Initialize an asset instance from this template
    template.createInstance(function(asset){
      console.log("Loaded asset " + asset.template.name + " from storage.");
      asset.overrideCategory = selectedAsset.overrideCategory; // Don't lose this
      asset.overrideCategory_safe = selectedAsset.overrideCategory;
      // Add asset to bone group of selected asset
      var boneGroup = boneGroups.get(selectedAsset.boneGroupUid);
      // remove mesh that's already there
      boneGroup.removeAsset(selectedAsset.uid);

      // add new mesh
      boneGroup.addAsset(asset);
      selectAsset(asset);
    });
  }

  function handleClickPoseItem(poseId){
    var template = poseTemplates[poseId];
    if (!template){
      console.error("No such pose template: " + poseId);
      return;
    }

    // Load pose from this template
    template.loadJSON(function(poseTemplate, poseJSON){
      console.log("Loaded pose " + poseTemplate.name + " from storage.");
      Pose.loadPose(poseJSON, boneGroups);
    });
  }

  function handleClickBoneGroupTemplate(boneGroupTemplateId){
    var template = boneGroupTemplates[boneGroupTemplateId];
    if (!template){
      console.error("No such bone group template: " + boneGroupTemplateId);
      return;
    }

    // Initialize an asset instance from this template
    template.createInstance(function(boneGroup){
      console.log("Loaded bone group " + boneGroup.template.name + " from storage.");
      // Add asset to bone group of selected asset
      if (selectedBoneGroup == null){
        // TODO: what to do if no bone group selected?
      } else {
        /*var boneGroup = boneGroups.get(selectedAsset.boneGroupUid);
        // remove mesh that's already there
        boneGroup.removeAsset(selectedAsset.uid);

        // add new mesh
        boneGroup.addAsset(asset);
        selectAsset(asset);*/
      }
    });
  }

  function handleClickPreset(presetId){
    loadPreset(presetId);
  }

  function handleModeClick(mode){
    setMode(mode);
  }

  function onLeftMouseDown(mouseX, mouseY){
    leftMouseDown = true;
    if (editMode !== 'none'){
      finalizeEdit();
    }
  }

  function onLeftMouseUp(mouseX, mouseY){
    leftMouseDown = false;

    view.finalizeCameraMove();
  }

  function onRightMouseDown(mouseX, mouseY){
    rightMouseDownXY = [mouseX, mouseY];

    if (editMode === 'rotate'){
      cancelBoneRotate();
      return;
    } else if (editMode === 'move'){
      cancelBoneMove();
      return;
    } else if (editMode === 'scale'){
      cancelBoneScale();
      return;
    }
  }

  function onRightMouseUp(mouseX, mouseY){
    if (mouseX == rightMouseDownXY[0] && mouseY == rightMouseDownXY[1]){
      onRightClick(mouseX, mouseY);
    }
    view.finalizeCameraMove();
  }

  function onRightClick(mouseX, mouseY){
    mouseY -= 30; // navigator panel

    console.log(mouseX, mouseY);
    /*if (mode == 'pose'){
      var clickVector = this.getClickVector(mouseX, mouseY, this.camera);
      this.raycaster.set(this.camera.position, clickVector.sub(this.camera.position).normalize());

      var intersections = this.raycaster.intersectObjects(this.boneHandles, false);
      var closestBone = null, closestDistance = null;
      for (var i = 0; i < intersections.length; i++){
        var boneHandle = intersections[i].object;
        var boneGroup = character.boneGroups.get(boneHandle.boneGroupUid);
        var bone = boneGroup.skeleton.bones[boneHandle.boneIndex];
        if (bone.name.startsWith("#")){
          continue;
        }
        if (closestBone === null || intersections[i].distance < closestDistance){
          closestBone = bone;
          closestDistance = intersections[i].distance;
        }
      }
      selectedBone = closestBone;

      if (closestBone == null){
        this.boneAxisHelper.visible = false;
      } else {
        this.boneAxisHelper.visible = true;
        console.log("Clicked on " + selectedBone.name);

        var globalBonePosition = new THREE.Vector3()
        this.scene.updateMatrixWorld();
        globalBonePosition.setFromMatrixPosition(closestBone.matrixWorld);
        rotationBoneOrigin = this.getScreenCoordinates(globalBonePosition);
      }
    } else */if (mode == "appearance" || mode == "components"){
      return; //simple mode
      var pickingTexture = meshPickingView.pickingTexture;
      view.renderer.render(meshPickingView.scene, view.camera, pickingTexture);
      var pixelBuffer = new Uint8Array(4);
      view.renderer.readRenderTargetPixels(pickingTexture, mouseX, pickingTexture.height - mouseY, 1, 1, pixelBuffer);
      
      // Create id from RGB values
      var colorId = ( pixelBuffer[0] << 16 ) | ( pixelBuffer[1] << 8 ) | ( pixelBuffer[2] );
      var assetUid = meshPickingView.assetUidMap[colorId];
      var assetResult = getAsset(assetUid);
      if (assetResult == null){
        selectAsset(null);
        selectBoneGroup(null);
        // this.hideLibrary("appearance");
      } else {
        //var boneGroupUid = assetResult[0];
        var asset = assetResult[1];
        if (mode == "appearance"){
          selectAsset(asset);
        } else if (mode == "components"){
          var boneGroup = boneGroups.get(asset.boneGroupUid);
          selectBoneGroup(boneGroup);
        }
        
        // this.libraryClearMeshes();
        // this.libraryPopulateMeshes(boneGroupUid);
        // this.showLibrary("appearance");
      }
    } else if (mode == "pose" || mode == "pose picking"){
      var pickingTexture = posePickingView.pickingTexture;
      view.renderer.render(posePickingView.scene, view.camera, pickingTexture);
      var pixelBuffer = new Uint8Array(4);
      view.renderer.readRenderTargetPixels(pickingTexture, mouseX, pickingTexture.height - mouseY, 1, 1, pixelBuffer);
      
      // Create id from RGB values
      var colorId = ( pixelBuffer[0] << 16 ) | ( pixelBuffer[1] << 8 ) | ( pixelBuffer[2] );
      var bone = posePickingView.boneMap[colorId];
      posePickingView.markBoneSelected(selectedBone, false);
      selectedBone = bone;
      posePickingView.markBoneSelected(selectedBone, true);
      if (bone){
        console.log(bone.name);

        var globalBonePosition = new THREE.Vector3()
        view.scene.updateMatrixWorld();
        globalBonePosition.setFromMatrixPosition(bone.matrixWorld);
        rotationBoneOrigin = getScreenCoordinates(globalBonePosition);
        console.log("rotationBoneOrigin: ", rotationBoneOrigin);
      } else {
        // deselect bone
      }
    }

      /*else if (mode == 'bone'){
      var pickingTexture = meshPickingView.pickingTexture;
      this.renderer.render(meshPickingView.scene, this.camera, pickingTexture);
      var pixelBuffer = new Uint8Array(4);
      this.renderer.readRenderTargetPixels(pickingTexture, mouseX, pickingTexture.height - mouseY, 1, 1, pixelBuffer);
      
      // Create id from RGB values
      var colorId = ( pixelBuffer[0] << 16 ) | ( pixelBuffer[1] << 8 ) | ( pixelBuffer[2] );
      var assetUid = meshPickingView.assetUidMap[colorId];     
      var assetResult = getAsset(assetUid);
      if (assetResult == null){
        this.selectBoneGroup(null);
      } else {
        boneGroupUid = assetResult[0];
        var boneGroup = character.boneGroups.get(boneGroupUid);
        this.selectBoneGroup(boneGroup);
      }
    }*/
  }

  function onMiddleMouseDown(mouseX, mouseY, event){
    console.log("Middle click");
  }

  function onMouseDown(event){
    if (event.button === 0){
      onLeftMouseDown(event.clientX, event.clientY, event);
    } else if (event.button == 1){
      onMiddleMouseDown(event.clientX, event.clientY, event);
    } else if (event.button == 2){
      onRightMouseDown(event.clientX, event.clientY, event);
    }
  }

  function onMouseUp(event){
    if (event.button === 0){
      onLeftMouseUp(event.clientX, event.clientY, event);
    } else if (event.button == 1){
      // Middle click
    } else if (event.button == 2){
      onRightMouseUp(event.clientX, event.clientY, event);
    }
  }

  function refreshSkeleton(){
    setTimeout(
      function(){
        posePickingView.update();
        view.requestRender();
      }, 300);
  }

  function clearBoneRotation(){
    if (!selectedBone){
      return;
    }

    selectedBone.rotation.setFromVector3(new THREE.Vector3(0, 0, 0));
    view.requestRender();
    refreshSkeleton();
  }

  function clearBoneLocation(){
    if (!selectedBone){
      return;
    }

    selectedBone.position.setX(0);
    selectedBone.position.setY(0);
    selectedBone.position.setZ(0);
    view.requestRender();
    refreshSkeleton();
  }

  function clearBoneScale(){
    if (!selectedBone){
      return;
    }

    selectedBone.scale.setX(1);
    selectedBone.scale.setY(1);
    selectedBone.scale.setZ(1);
    view.requestRender();
    refreshSkeleton();
  }

  function startBoneRotate(mouseX, mouseY){
    if (!selectedBone){
      return;
    }

    console.log("Entering rotate mode.");
    editMode = 'rotate';
    initialRotation = selectedBone.rotation.clone();
    editAxis = null;

    editMouseOriginX = mouseX;
    editMouseOriginY = mouseY;
  }

  function startBoneMove(mouseX, mouseY){
    if (!selectedBone){
      return;
    }

    console.log("Entering move mode.");
    editMode = 'move';
    initialPosition = selectedBone.position.clone();
    editAxis = null;

    editMouseOriginX = mouseX;
    editMouseOriginY = mouseY;
  }

  function startBoneScale(mouseX, mouseY){
    if (!selectedBone){
      return;
    }

    console.log("Entering scale mode.");
    editMode = 'scale';
    initialScale = selectedBone.scale.clone();
    editAxis = null;

    editMouseOriginX = mouseX;
    editMouseOriginY = mouseY;
  }

  function finalizeEdit(){
    editMode = 'none';
    posePickingView.update();
  }

  function cancelEdit(){
    if (editMode === 'rotate'){
      cancelBoneRotate();
    } else if (editMode === 'move'){
      cancelBoneMove();
    } else if (editMode === 'scale'){
      cancelBoneScale();
    }
  }

  function cancelBoneRotate(){
    console.log("Cancelling bone rotate.");
    selectedBone.rotation.setFromVector3(initialRotation);
    editMode = 'none';
    currentNumberString = '';
    setTimeout(
      function(){
        posePickingView.update();
        requestRender();
      }, 500);
  }

  function cancelBoneMove(){
    console.log("Cancelling bone move.");
    selectedBone.position.x = initialPosition.x;
    selectedBone.position.y = initialPosition.y;
    selectedBone.position.z = initialPosition.z;
    editMode = 'none';
    currentNumberString = '';
    setTimeout(
      function(){
        posePickingView.update();
        requestRender();
      }, 500);
  }

  function cancelBoneScale(){
    console.log("Cancelling bone scale.");
    selectedBone.scale.x = initialScale.x;
    selectedBone.scale.y = initialScale.y;
    selectedBone.scale.z = initialScale.z;
    editMode = 'none';
    currentNumberString = '';
    setTimeout(
      function(){
        posePickingView.update();
        requestRender();
      }, 500);
  }

  function setEditAxis(axis){
    if (editMode === 'rotate'){
      selectedBone.rotation.setFromVector3(initialRotation);
    } else if (editMode === 'move'){
      selectedBone.position.x = initialPosition.x;
      selectedBone.position.y = initialPosition.y;
      selectedBone.position.z = initialPosition.z;
    } else if (editMode === 'scale'){
      selectedBone.scale.x = initialScale.x;
      selectedBone.scale.y = initialScale.y;
      selectedBone.scale.z = initialScale.z;
    } else {
      console.error("Cannot set edit axis, not in any edit mode.");
      return;
    }

    if (axis == 'X' || axis == 'x'){
      editAxis = 'X';
    } else if (axis == 'Y' || axis == 'y'){
      editAxis = 'Y';
    } else if (axis == 'Z' || axis == 'z'){
      editAxis = 'Z';
    }
    console.log("Edit axis set to " + editAxis + ".");
  }

  function getScreenCoordinates(obj){
    var editor_panel = document.getElementById('editor_panel');
    var vector = obj.clone();
    var windowWidth = editor_panel.offsetWidth;

    var widthHalf = (windowWidth/2);
    var heightHalf = (editor_panel.offsetHeight/2);

    vector.project(view.camera);

    vector.x = ( vector.x * widthHalf ) + widthHalf;
    vector.y = - ( vector.y * heightHalf ) + heightHalf;
    vector.z = 0;

    return vector;
  }

  function getClickVector(mouseX, mouseY, camera){
    var editor_panel = document.getElementById('editor_panel');
    var vector = new THREE.Vector3(
      ( mouseX / editor_panel.offsetWidth ) * 2 - 1,
      - ( mouseY / editor_panel.offsetHeight ) * 2 + 1,
      0.5
    );
    vector.unproject(camera);
    return vector;
  }

  function updateBoneEdits(mouseX, mouseY, number){
    if (editMode === 'none'){
      return;
    } else if (editMode === 'rotate'){
      var factor = 500.0;

      var dx = (editMouseOriginX - rotationBoneOrigin.x);
      var dy = (editMouseOriginY - rotationBoneOrigin.y);
      var angle1 = Math.atan2(dy, dx);

      dx = (mouseX - rotationBoneOrigin.x);
      dy = (mouseY - rotationBoneOrigin.y);
      var angle2 = Math.atan2(dy, dx);

      var combinedAngle = angle1 - angle2;

      if (number){ // override mouse position if typing number
        combinedAngle = number * Math.PI / 180.0;
      }

      selectedBone.rotation.setFromVector3(initialRotation);
      selectedBone.updateMatrix();
      var rotation = selectedBone.parent.getWorldRotation()
      var inverseRotation = new THREE.Euler(rotation.x * -1, rotation.y * -1, rotation.z * -1, rotation.order);

      if (editAxis == 'X'){
        var axisClone = X_AXIS.clone();
        axisClone.applyEuler(inverseRotation);
        selectedBone.rotateOnWorldAxis(axisClone, combinedAngle);
      } else if (editAxis == 'Y'){
        var axisClone = Y_AXIS.clone();
        axisClone.applyEuler(inverseRotation);
        selectedBone.rotateOnWorldAxis(axisClone, combinedAngle);
      } else if (editAxis == 'Z'){
        var axisClone = Z_AXIS.clone();
        axisClone.applyEuler(inverseRotation);
        selectedBone.rotateOnWorldAxis(axisClone, combinedAngle);
      } else {
        var editor_panel = document.getElementById('editor_panel');
        var cameraAxis = getClickVector(editor_panel.offsetWidth/2, editor_panel.offsetHeight/2, view.camera);
        cameraAxis.applyEuler(inverseRotation);
        selectedBone.rotateOnWorldAxis(cameraAxis, combinedAngle);
      }
    } else if (editMode === 'move'){
      var dx = (mouseX - editMouseOriginX);
      var dy = (mouseY - editMouseOriginY);
      //var distance = Math.sqrt(dx * dx + dy * dy);

      if (number){ // override mouse position if typing number
        if (editAxis == 'X'){
          selectedBone.position.x = initialPosition.x + number;
        } else if (editAxis == 'Y'){
          selectedBone.position.y = initialPosition.y + number;
        } else if (editAxis == 'Z'){
          selectedBone.position.z = initialPosition.z + number;
        }
      } else {
        if (editAxis == 'X'){
          selectedBone.position.x = initialPosition.x + dx/100.0;
        } else if (editAxis == 'Y'){
          selectedBone.position.y = initialPosition.y - dy/100.0;
        } else if (editAxis == 'Z'){
          selectedBone.position.z = initialPosition.z + dx/100.0;
        }
      }

    } else if (editMode === 'scale'){
      //TODO: This 'distance1' stuff doesn't need to be calculated each time the mouse is moved. Same above.
      var dx = (editMouseOriginX - rotationBoneOrigin.x);
      var dy = (editMouseOriginY - rotationBoneOrigin.y);
      var distance1 = Math.sqrt(dx * dx + dy * dy);

      var dx = (mouseX - rotationBoneOrigin.x);
      var dy = (mouseY - rotationBoneOrigin.y);
      var distance2 = Math.sqrt(dx * dx + dy * dy);
      
      var scaleAmount = (distance2 - distance1)/200.0;

      if (number){ // override mouse position if typing number
        if (editAxis == 'X'){
          selectedBone.scale.x = initialScale.x * number;
        } else if (editAxis == 'Y'){
          selectedBone.scale.y = initialScale.y * number;
        } else if (editAxis == 'Z'){
          selectedBone.scale.z = initialScale.z * number;
        } else {
          selectedBone.scale.x = initialScale.x * number;
          selectedBone.scale.y = initialScale.y * number;
          selectedBone.scale.z = initialScale.z * number;
        }

        console.log(number);
      } else {
        if (editAxis == 'X'){
          selectedBone.scale.x = initialScale.x + scaleAmount;
        } else if (editAxis == 'Y'){
          selectedBone.scale.y = initialScale.y + scaleAmount;
        } else if (editAxis == 'Z'){
          selectedBone.scale.z = initialScale.z + scaleAmount;
        } else {
          selectedBone.scale.x = initialScale.x + scaleAmount;
          selectedBone.scale.y = initialScale.y + scaleAmount;
          selectedBone.scale.z = initialScale.z + scaleAmount;
        }
      }
    }
    view.requestRender();
  }

  function onMouseMove(event){
    var mouseX = event.clientX;
    var mouseY = event.clientY;
    lastMouseX = mouseX;
    lastMouseY = mouseY;
    updateBoneEdits(mouseX, mouseY);
  }

  function onKeyDown(event){
    var keynum; 
    if(window.event) { // IE                    
      keynum = event.keyCode;
    } else if(event.which){ // Netscape/Firefox/Opera                   
      keynum = event.which;
    }

    if (keynum == 46){ // Delete
      onDeletePressed();
    } else if (keynum == 219){ // 
      setMode('mesh picking');
    } else if (keynum == 221){ // 

    }

    var letter = String.fromCharCode(keynum);

    if (letter == 'P' || letter == 'p'){
      setMode('pose');
    } else if (letter == 'M' || letter == 'm'){
      setMode('appearance');
    } else if (letter == 'B' || letter == 'b'){
      setMode('components');
    } else if (letter == 'R' || letter == 'r'){
      if (event.altKey){
        clearBoneRotation();
      } else {
        startBoneRotate(lastMouseX, lastMouseY);
      }
    } else if (letter == 'G' || letter == 'g'){
      if (event.altKey){
        clearBoneLocation();
      } else {
        startBoneMove(lastMouseX, lastMouseY);
      }
    } else if (letter == 'S' || letter == 's'){
      if (event.altKey){
        clearBoneScale();
      } else {
        startBoneScale(lastMouseX, lastMouseY);
      }
    } else if ('XxYyZz'.indexOf(letter) != -1){
      setEditAxis(letter);
    } else if (editMode === 'rotate' || editMode === 'move' || editMode === 'scale'){
      if (keynum == 13){ // ENTER
        finalizeEdit();
        currentNumberString = '';
      } else if (keynum == 27){ // ESCAPE
        cancelEdit();
        currentNumberString = '';
      } else if (keynum == 190){ // PERIOD
        currentNumberString += '.';
      } else if (keynum == 189){ // SUBTRACT
        currentNumberString += '-';
      } else {
        // else is this a number?
        currentNumberString += letter;

        var number = parseFloat(currentNumberString);
        if (number){
           updateBoneEdits(0, 0, number);
        }
      }
    }
    console.log(currentNumberString);

    // if (editMode === 'rotate'){
    //   cancelBoneRotate();
    //   return;
    // } else if (editMode === 'move'){
    //   cancelBoneMove();
    //   return;
    // } else if (editMode === 'scale'){
    //   cancelBoneScale();
    //   return;
    // }

    



    
}


</script>
